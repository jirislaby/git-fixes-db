#!/usr/bin/perl -w
use strict;
use DBI qw(:sql_types);
use Git;
use Getopt::Long;
use Term::ANSIColor qw(colored);

my $db_file = 'cve-fixes.db';
my $git_ks = $ENV{'KSOURCE_GIT'} // '/home/latest/repos/suse/kernel-source';
my $db;

GetOptions(
	'db=s' => \$db_file,
	'git-kernel-source=s' => \$git_ks,
) or die("Error in command line arguments\n");

my $repo_ks = Git->repository(Directory => $git_ks);

$db = DBI->connect("dbi:SQLite:dbname=$db_file", undef, undef,
	{AutoCommit => 0}) or
	die "connect to db error: " . DBI::errstr;

$db->do('PRAGMA foreign_keys = ON;') or
	die "cannot enable foreign keys";

my @tables = (
	[ 'branch', 'id INTEGER PRIMARY KEY', 'branch TEXT NOT NULL UNIQUE',
		'kver INTEGER NOT NULL' ],
	[ 'shas', 'id INTEGER PRIMARY KEY', 'sha TEXT NOT NULL',
		'upstream INTEGER NOT NULL CHECK (upstream IN (0, 1))',
		'UNIQUE(sha, upstream)'],
	[ 'refs', 'id INTEGER PRIMARY KEY', 'ref TEXT NOT NULL UNIQUE' ],
	[ 'fixes', 'id INTEGER PRIMARY KEY',
		'sha INTEGER NOT NULL REFERENCES shas(id) ON DELETE CASCADE',
		'ref INTEGER NOT NULL REFERENCES refs(id) ON DELETE CASCADE',
		'potential INTEGER NOT NULL CHECK (potential IN (0, 1))',
		'fixed_by INTEGER REFERENCES shas(id) ON DELETE CASCADE',
		'branch INTEGER NOT NULL REFERENCES branch(id) ON DELETE CASCADE',
		q/created TEXT NOT NULL DEFAULT (datetime('now', 'localtime'))/,
		q/updated TEXT NOT NULL DEFAULT (datetime('now', 'localtime'))/,
		'UNIQUE(sha, branch)' ],
);

foreach my $entry (@tables) {
	my $name = shift @{$entry};
	my $desc = join ', ', @{$entry};
	$db->do("CREATE TABLE IF NOT EXISTS $name($desc) STRICT;") or
		die "cannot create table '$name'";
}

$db->do('CREATE INDEX IF NOT EXISTS fixed_by ON fixes(fixed_by);') or
	die "cannot create index fixed_by";
$db->do('CREATE TRIGGER IF NOT EXISTS fixes_updated ' .
	'AFTER UPDATE ON fixes ' .
	q/BEGIN UPDATE fixes SET updated=datetime('now', 'localtime') WHERE id=NEW.id; END;/) or
	die "cannot create trigger fixes_updated";
$db->do('CREATE VIEW IF NOT EXISTS fixes_expand AS ' .
	'SELECT fixes.id, fixes.potential, branch.branch, branch.kver, ' .
		'substr(shas_u.sha, 1, 12) AS sha, ' .
		'substr(shas_s.sha, 1, 12) AS fixed_by, ' .
		'refs.ref, fixes.created, fixes.updated ' .
	'FROM fixes ' .
	'LEFT JOIN branch ON fixes.branch = branch.id ' .
	'LEFT JOIN shas AS shas_u ON fixes.sha = shas_u.id AND shas_u.upstream = 1 ' .
	'LEFT JOIN shas AS shas_s ON fixes.fixed_by = shas_s.id AND shas_s.upstream = 0 ' .
	'LEFT JOIN refs ON fixes.ref = refs.id;') or
	die "cannot create VIEW fixes_expand";
$db->do('CREATE VIEW IF NOT EXISTS fixes_expand_sorted AS ' .
	'SELECT * FROM fixes_expand ' .
	'ORDER BY kver, branch, id;') or
	die "cannot create VIEW fixes_expand_sorted";

my $ins = $db->prepare('INSERT INTO fixes(sha, ref, potential, branch) ' .
	'SELECT shas.id, refs.id, ?, branch.id FROM shas, refs, branch ' .
	'WHERE shas.sha=? AND refs.ref=? AND branch.branch=?;') or
	die "cannot prepare fixes";
$ins->{PrintError} = 0;
my $ins_branch = $db->prepare('INSERT OR IGNORE INTO branch(branch, kver) VALUES (?, ?);') or
	die "cannot prepare branch";
my $ins_sha = $db->prepare('INSERT OR IGNORE INTO shas(sha, upstream) VALUES (?, 1);') or
	die "cannot prepare sha";
my $ins_ref = $db->prepare('INSERT OR IGNORE INTO refs(ref) VALUES (?);') or
	die "cannot prepare sha";

my $ref;

while (<>) {
	if (/^Security fix for (.*) with CVSS/) {
		$ref = $1;
		$ins_ref->execute($ref);
		next;
	}

	next unless /^([^:]+): MANUAL: (might need )?backport(?: of)? ([a-f0-9]+) /;

	my $branch = $1;
	my $potential = defined $2 ? 1 : 0;
	my $sha = $3;
	my $kver = $repo_ks->command_oneline('grep', '-h', '^SRCVERSION=', "origin/$branch",
		'--', 'rpm/config.sh');
	my ($maj, $min) = $kver =~ /.*=([0-9]+)\.([0-9]+)/;
	die "no kernel version for $branch in $kver" unless ($min);

	print "ref='$ref' sha=$sha potential=$potential branch=$branch ($maj.$min)\n";
	$ins_branch->execute($branch, $maj * 100 + $min);
	$ins_sha->execute($sha);

	if (!$ins->execute($potential, $sha, $ref, $branch)) {
		die "cannot insert: " . $ins->errstr
			if ($ins->errstr !~ /UNIQUE constraint failed/);
		print colored("\tskipped a dup\n", "yellow")
	}
}

END {
	if (defined $db && $db->{Active}) {
		$db->commit;
		$db->disconnect;
	}
}

0;
